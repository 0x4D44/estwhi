**Goal**

- Port Estimation Whist to a modern, single-EXE Rust app named `estwhi.exe`.
- Use Win32 APIs via the `windows` (windows-rs) crate; no WinUI/.NET/UWP runtimes.
- Preserve the classic look-and-feel and screen layout while separating core logic from UI.

**Constraints**

- Runtime dependencies: only Windows system DLLs (USER32, GDI32, COMCTL32, KERNEL32).
- No external UI frameworks; use classic Win32 windows, GDI, and common controls.
- Keep INI-based configuration for continuity; store under `%APPDATA%\\Estwhi\\estwhi.ini`.

**Architecture**

- `estwhi-core` (Rust library)
  - Pure game logic and data types: `Suit`, `Rank`, `Card`, `Deck`, `Player`, `GameConfig`, `GameState`, `RoundState`, `Bid`, `ScoreMode`.
  - Algorithms: mountain dealing, Fisher–Yates shuffle, legal-play enforcement, trick winner, scoring (Vanilla/Squared + hard score), bidding AI (weights-based), RNG seeding.
  - No OS APIs. Deterministic tests with seed control.

- `estwhi-win32` (Rust binary)
  - Win32 shell: class registration, message loop, menus, accelerators, timers, dialogs.
  - Rendering: GDI with double-buffering; DPI-aware layout.
  - Persistence: Win32 profile APIs to INI; high scores and options mirrored from the classic app.
  - Resources: icons, version, 52 card bitmaps, suit icons, dialog templates, string table.

- Build-time assets
  - `resources/app.rc` compiled by `rc.exe` via `build.rs` (e.g., `winres`).
  - Output binary name: `estwhi.exe` (Cargo package name = `estwhi`).

**Configuration & Persistence**

- INI at `%APPDATA%\\Estwhi\\estwhi.ini` (migrate from local `ESTWHI.INI` if present).
- Keys retained: window size/pos, number of players, max cards, score mode, next-card notify (Dialog/Mouse), confirm exit, hard score, cheat/prob window geometry, icon twirl/random (optional), top-10 high scores (names + values).
- APIs: `GetPrivateProfileStringW`/`WritePrivateProfileStringW` via `windows` crate.

**Assets (Card Bitmaps & Icons)**

- Option A (faithful/fast): extract 52 card BMPs and suit logos from the legacy resources; embed as Win32 `BITMAP` resources with numeric IDs `1..52` to match original code assumptions. Load using `LoadImageW(..., LR_CREATEDIBSECTION)`.
- Option B (later): procedural card rendering with GDI (scales better, different look). Gate behind a config toggle.
- Resource layout: app icon, version info, `BITMAP` 1..52, suit icons (`CLUB`, `DIAMOND`, `HEART`, `SPADE`), small logos, dialog templates.

**Screen Layout (Preserve Classic UI, DPI-Aware)**

- Regions
  - Table area (played cards): top-left rectangle with player labels beneath cards.
  - Information panel: right-side box with three columns “Calls/Tricks/Scores” and one row per player; trump indicator and “Last trick won by …”.
  - Status bar: bottom band with instructional text.
  - Hand area: bottom cards band with overlap and inverted/gray rendering for illegal cards.

- Layout rules
  - Base card size 71x96 at 96 DPI; scale by `dpi/96` and clamp.
  - Overlap computation for `n` cards: `act_width = min(card_w + pad, max(min_overlap, (hand_w - card_w) / max(1, n-1)))`.
  - Store per-card hit rectangles; redraw on `WM_SIZE`, `WM_PAINT`, and state changes.
  - Double-buffer all paints using a memory DC to avoid flicker.

**Win32 Implementation Notes**

- Crates: `windows` (features: Foundation, UI.WindowsAndMessaging, Graphics.Gdi, UI.Controls, System.SystemServices, Storage.FileSystem), `rand`, optional `thiserror`.
- Windowing: register main WNDCLASS, create menus (GAME/HELP), status bar area, accelerator table.
- Dialogs: define in `.rc`, shown with `DialogBoxParamW`.
- Timers: `SetTimer` for icon twirl/random things (optional) and “Mouse” notify mode.
- Strings: centralize in a small string table to ease localization.

**Staged Implementation (8 Stages)**

1) Project Scaffolding
- Cargo workspace: `estwhi-core` (lib), `estwhi` (bin => outputs `estwhi.exe`).
- Add `windows`, `rand`; `winres` as build-dep; set subsystem/windows and version info.
- Directory skeleton: `resources/app.rc`, `assets/` (source BMPs), `build.rs`.

2) Core Game Model + Tests
- Implement `Card`, `Suit`, `Rank`, `Deck` (Fisher–Yates), `GameConfig`, `GameState`, `RoundState`.
- Implement legality, trick resolution, scoring (Vanilla/Squared + hard score), mountain deal.
- Implement bidding AI: weight tables from legacy `CallValueOne/Two` and last-bidder adjustment.
- Unit tests: mountain deal sequence, winner logic, scoring variants, legality, last-bidder rule, seeded shuffle.

3) Resources & Asset Pipeline
- Extract/prepare 52 card BMPs + suit icons; define numeric IDs to mirror legacy.
- Author `resources/app.rc` (icons, version, bitmaps, dialogs, strings).
- `build.rs` compiles `.rc` and links resources into `estwhi.exe`.

4) Win32 Shell & Layout Skeleton
- Register window class; create main window, menus, accelerators, status band.
- Compute DPI-aware rectangles for Table/Info/Hand.
- `WM_PAINT` draws boxes and labels as placeholders; double-buffer structure in place.

5) Rendering & Input
- Draw played cards, trump indicator, last-winner text, Calls/Tricks/Scores grid.
- Draw hand with overlap and illegal-card highlighting; compute and store hit-test rects.
- Handle mouse: select and play legal card; `WM_SIZE` reflow; eliminate flicker.

6) Game Flow Wiring
- Hook UI to `core` intents: Deal → Bidding (AI → human dialog → AI) → Trick loop (AI lead/response, human click) → Winner → Next trick/round → Scoring → Game over.
- Implement both notify modes: Dialog vs Mouse click to continue.
- Status messages mirrored from the classic app.

7) Options, Persistence, Scores
- Implement Options dialog; apply to live `GameConfig` and write to INI.
- Implement Scores dialog, high-score update and name entry.
- Implement About dialog with classic strings (Version 1.2 date preserved).

8) Optional Windows & Polish
- Probability window: render grid from `core` (initially uniform); future hook for inference.
- Cheat window: draw all hands (debug-only toggle).
- HiDPI polish, keyboard shortcuts, version resource, CI build, code signing (as needed).

**Mapping Old → New**

- `TMainWindow` → `MainWindow` (WndProc bridge) + `Controller` managing `GameState` and `ViewLayout`.
- `TOptions`, `TCallWin`, `TScoreBox`, `TAboutBox` → modal Win32 dialogs defined in `.rc` and backed by small dialog procs.
- INI key names preserved where sensible; geometry persisted per monitor DPI.

**Testing Strategy**

- `estwhi-core`: comprehensive unit tests (rules, scoring, legality, AI rounding/last-bidder).
- Golden tests for seeded shuffle and full-round scoring.
- Manual QA checklist for the Win32 front-end; optional accelerator-only code paths for basic automation.

**Dependencies & Packaging**

- Crates: `windows`, `rand`, `winres` (build-only), optional `thiserror`.
- Output: single `estwhi.exe` with embedded resources; no external runtimes.

**Build & Output**

- Workspace package name for the binary crate: `estwhi` to produce `target\\{profile}\\estwhi.exe`.
- `build.rs` runs `rc.exe` to embed `resources/app.rc`.
- Recommended targets: `x86_64-pc-windows-msvc` (primary) and `i686-pc-windows-msvc` (optional 32-bit).

**Risks & Mitigations**

- Asset licensing: confirm rights to distribute legacy BMPs; if unclear, switch to procedural cards.
- DPI/Scaling differences: use DIB sections and `StretchDIBits` to scale cleanly; test at 100/125/150%.
- Input timing/flow: keep UI state machine explicit; avoid reentrancy during modal dialogs.
- Shuffle parity: document algorithm change to Fisher–Yates; keep seed option for reproducibility.

**Next Steps (Immediate)**

- Approve architecture and staged plan; confirm we ship with embedded legacy card art.
- I can scaffold the Cargo workspace and `resources/app.rc`, with stubs for window class, menus, and a placeholder paint that draws the three regions and status bar.
