**Estwhi Codebase Investigation (Estimation Whist)**

- Author: M. G. (Martin) Davidson
- App name: Estimation Whist (window class: "Estimation Whist window")
- Primary language: Turbo Pascal for Windows 1.5 (TPW v1.5)
- UI framework: Borland ObjectWindows for TPW (unit `WObjects`) + Win16 API (`Win31`, `WinTypes`, `WinProcs`) and CTL3D (`Ctl3d.dll`)
- Platform target: Windows 3.1x, 16‑bit
- Project versioning in code: v1.2 dated 01/08/2002 (dd/mm/yyyy)
- Packaging: standalone EXE with WinHelp `.HLP` and compiled resources `.RES`

**Repository Layout**

- `estwhi.pas` — Main and essentially entire application source (monolithic). Richly commented, ~3,900+ lines.
- `estwhi_v11.pas` — Prior variant of the main source (v1.1 era).
- `ESTWHI.RES`, `ABOUT.RC`, `RESOURCE.BAT` — Resources and resource build helper (uses Borland Resource Compiler). `ABOUT.RC` text is stale; runtime text is set from code.
- `HELP/` — WinHelp 3.1 project: `ESTWHI.HPJ`, `ESTWHI.RTF`, bitmaps (`*.BMP`), segmented graphics (`*.SHG`), and generated artifacts.
- `RELEASE/ESTWHI.ZIP` — Published build archive (exe + help).
- Binaries for convenience: `ESTWHI.EXE`, `CTL3D.DLL`.

**What The Program Does**

Estimation Whist is a trick‑taking card game (a.k.a. Oh Hell!/Estimation). The app lets a human play against computer players. Each round deals a varying number of cards, players bid (“call”) tricks, then play tricks following suit with a rotating trump. Scoring has selectable modes.

**Build/Run Tooling**

- Compiler: Turbo Pascal for Windows v1.5 (16‑bit). Units used: `WObjects`, `StdDlgs`, `Strings`, `WinDos`, etc.
- Resources: Borland RC via `RESOURCE.BAT` (`rc estwhi.res`). Card bitmaps and icons are embedded.
- Help: WinHelp 3.1 (`ESTWHI.HPJ` specifies `hc 3.1`).
- Persistence: Win16 profile APIs (`Get/WritePrivateProfileString/Int`) to `ESTWHI.INI`.
- Note: This is a legacy 16‑bit Windows app; modern 64‑bit Windows cannot run it natively. Use a 16‑bit VM (Windows 3.1/9x) or emulator (e.g., DOSBox + Win3.x) for execution. Rebuilding requires TPW 1.5 and Borland’s tools.

**High‑Level Architecture**

- Program: `PROGRAM EstWhi;` in `estwhi.pas`.
- Application object: `TCardApp = OBJECT(TApplication)` bootstraps the main window.
- Main window: `TMainWindow = OBJECT(TWindow)` orchestrates game state, input, drawing, AI, rounds, scoring, menus, timers, dialogs.
- Major UI components (ObjectWindows dialogs/windows):
  - `TStatbar` — simple owner‑drawn status bar.
  - `TCallWin` — call/bid dialog for the human (buttons for 0..15).
  - `TOptions` — options dialog (players, max cards, notify mode, scoring, hard‑score, cheat cards).
  - `TScoreBox` — high scores (top 10 names + scores).
  - `TAboutBox` — About dialog (strings set in code: “Estimation Whist”, “Version 1.2”, “Released: 01/08/2002”).
  - `TChetBox` — optional “cheat cards” window drawing all hands for debugging/cheating.
  - `TProbWin` — “Probability” window (displays per‑card short integers). Current values are initialized trivially (see below).
  - `TRandom` — “Random things” demo window (UI toys: icon twirl, random walkers).

**Core Data Model**

- Card identity: integers 1..52, where each suit is a 13‑card block and aces are numbered as 1, 14, 27, 40 (ace high). Text mapping arrays: `TextCardVals1`, `TextCardVals2`, `TextCardSuits` (`'CDSH'`).
- Hands and play:
  - `HandCards[Player, Slot]` — player hands (0 when slot empty).
  - `LegalHandCards[Player, Slot]` — legality mask set by `ObtainLegal` (must follow led suit if possible).
  - `CardPlayed[Player]` — card laid this trick.
- Game meta:
  - `NoPlayers` (max 6), `MaxCards` (per hand upper bound, default 13), `RoundNo`, `Trump` (1..4), `StartPlayer`, `LastPlayer`, `NoCards` (current trick’s cards left), `NumberofRounds`.
  - `PlayCall[Player]` — bids; `Tricks[Player]` — tricks won; `Score[Player]` — cumulative score.
- AI bidding support:
  - `CardVal[1..13]` and `TrumpCardVal[1..13]` — per‑rank weights (two presets).
  - `Sel[Suit, Feature]` — simple per‑suit feature markers used by legacy `AutoCall`.
  - `TempPlayCall[Player]` — working float before rounding to `PlayCall`.
- Probability UI: `Probability[Player, Card]` — displayed by `TProbWin`. Initialized uniformly to `(100 * NoCards) div 52` for all entries at round start (no posterior updates in gameplay).
- Graphics: `CardPic[1..52]` per‑card bitmap resources; suit icons; `BackPic[]` for backs (not heavily used).

**Game Flow**

- New deal (`GameDeal` → `StartRound`):
  - Increment round and rotate trump suit (`Trump` cycles 1..4).
  - Compute `DealtCards`: counts up to `MaxCards` then down (mountain deal).
  - `Shuffle` → `Deal` → `SortCards`.
  - Initialize `Probability` entries uniformly.
  - AI players bid first if they precede the human; human makes a call via `TCallWin`; remaining AI bid. Bidding uses `AutoCallTwo`.
  - Draw UI elements (hand, table, info box).
- Playing a trick:
  - If someone else leads: `PlayLead` (AI selects a random card from its hand). Otherwise AI uses `PlayCard` (random legal card after `ObtainLegal`).
  - Human selects a legal card with the mouse; legality enforced.
  - After all players lay a card: `DecideWinner` determines trick winner → increments `Tricks`, updates `StartPlayer` to winner for next trick.
  - After last trick in the hand: `CalculateScore`, maybe end game (highest `Score` wins), update high scores, persist to INI.

**Key Algorithms**

- Shuffle: fills `Cards[1..52]` sequentially, then performs 1000 random swaps of two random positions. Simple but not Fisher–Yates; quality is adequate for casual play.
- Deal: sequentially deals `NoCards` from `Cards` into `HandCards[Player, Slot]` per player.
- Sort hand: selection‑style pass to order by increasing card number per suit, then a pass to push aces high within each suit block.
- Legal move computation (`ObtainLegal`): identifies led suit from `CardPlayed[StartPlayer]`; marks only same‑suit cards as legal unless none exist.
- Trick winner (`DecideWinner`):
  - If any trumps played: consider only trump cards; otherwise consider only cards of the led suit.
  - Within considered set, highest rank wins; aces are treated as highest by mapping ace to a sentinel value during comparison.
- Scoring (`CalculateScore`): two selectable modes with optional “hard score” rule.
  - `Vanilla`: `Score += Tricks`; if `PlayCall == Tricks` add bonus 10 (unless HardScore zero‑bid lockout applies — see below). Reset `Tricks` after scoring.
  - `Squared`: if `PlayCall == Tricks`, add `10 + (Tricks^2)`, else add `Tricks`.
  - HardScore option: when total bids for the hand are less than the number of cards dealt and a player called zero, the 10‑point bonus is not available (`AvailableBonus := 0`).
- Bidding AI:
  - `AutoCallTwo` (used): sums per‑card weights from `CardVal` / `TrumpCardVal` depending on rank and whether the card is trump. Two preset tables exist (`CallValueOne`, `CallValueTwo`), selected lazily into arrays and flagged by `CardValSetting`.
    - After summing weights, rounds with `TRUNC(value + 0.5)`.
    - Last‑to‑bid rule: ensures total bids don’t equal `NoCards` (adjusts last bidder away from making the sum exact).
  - `AutoCall` (older, still present): uses suit features in `Sel` and helper `CallUa` to increment a floating `TempPlayCall` based on combinations (e.g., holding KQJx in trump). Not currently called in the main flow.
- Probability display: initialized uniformly at start of round; no subsequent updates to reflect information gained during play. UI only.

**UI Rendering**

- Manual GDI drawing to the main window DC:
  - `DrawCards` lays out and draws the human’s hand bitmaps with overlap based on available width; illegal cards rendered with inverted raster op.
  - `DrawPlayedCards` renders the current trick’s cards in seating order with player labels.
  - `DrawInformation` panel shows Calls/Tricks/Scores, last‑trick winner, and trump suit indicator; also draws suit icon and a small logo.
  - `TStatbar` writes guidance messages (e.g., prompts for bidding, click‑to‑continue).
- User options include: number of players (up to 6), max cards (up to 15), notify mode for next trick (dialog vs mouse click), scoring mode (Vanilla/Squared), Hard scoring, “Cheat cards” window toggle, and cosmetic “Random things”.

**Persistence (INI) and Help**

- INI file `ESTWHI.INI`: stores geometry, options, scores, names, probability window placement, and feature toggles via Win16 profile APIs on both load and exit.
- WinHelp (`HELP/ESTWHI.HPJ` + `HELP/ESTWHI.RTF`): Contains comprehensive user docs (rules, options, scoring). The help file text refers to v1.1 (20 July 2002); the running app reports v1.2 (01 Aug 2002).

**Notable Artifacts and Mismatches**

- `ABOUT.RC` caption and labels reference “Nonogram Solver”; the live About box strings are set at runtime to Estimation Whist v1.2. The RC file appears to be a leftover template.
- Spelling/typos in comments and constants (`DECSRIPTION`, `mulitplier`, `mehod`).
- Probability window is cosmetic; values are uniform and not gameplay‑informed.

**Assumptions and Conventions**

- Card numbering: 1..13 Clubs, 14..26 Diamonds, 27..39 Spades, 40..52 Hearts (suit order inferred from suit constants and logic). Aces compare highest even though numerically low; code special‑cases them in comparisons and during sort.
- Trump cycles each round in order 1..4.
- Mountain deal pattern: rounds count up to `MaxCards` then mirror back down to 1.

**Limitations and Risks**

- 16‑bit only. Requires legacy environment. CTL3D.DLL dependency.
- Random AI for card play (lead/response) is weak; bidding heuristic is simplistic.
- Shuffle quality non‑optimal (swap shuffles vs linear Fisher–Yates).
- No test suite; monolithic Pascal source couples UI, state, logic, and rendering.

**If You Needed To Build or Run**

- Tools: Turbo Pascal for Windows v1.5, Borland Resource Compiler, HC 3.1 for WinHelp.
- Steps (historical, approximate):
  - Compile resources: run `RESOURCE.BAT` (adjust path to `rc`).
  - Build `estwhi.pas` in TPW, producing `ESTWHI.EXE` linked with `ESTWHI.RES` and referencing `CTL3D.DLL`.
  - Compile help: `hc ESTWHI.HPJ` to produce `ESTWHI.HLP`.
  - Ship: `ESTWHI.EXE`, `ESTWHI.HLP`, plus `CTL3D.DLL` if target lacks it.
- Run in Windows 3.1x/9x, or in a VM/emulator configured for 16‑bit Windows.

**Modernization Notes (Optional Future Work)**

- Port core game logic to a modern language (e.g., Free Pascal/Lazarus or C++/Qt), isolating model (cards, rules, scoring) from UI. Replace WinHelp with HTML/Markdown help.
- Improve shuffling (Fisher–Yates), bidding (Monte Carlo or rule‑based), and play AI (search with heuristics; card‑counting of known information).
- Introduce tests around: deal correctness, legal move enforcement, winner selection, scoring edge cases, last‑bidder adjustment rule, and mountain deal sequence.
- Decouple rendering from state; adopt MVC/MVU patterns; make player count, deck graphics, and scoring variants data‑driven.

**Quick Pointers To Code**

- Entry and app bootstrap: `estwhi.pas: CardApp.Init('ESTWHI'); CardApp.Run;` (bottom of file).
- Main types and globals: `estwhi.pas` near `TYPE`/`VAR` sections (`TMainWindow`, `HandCards`, `PlayCall`, etc.).
- Bidding AI: `AutoCallTwo`, `CallValueOne`, `CallValueTwo` (weights); last‑bidder adjustment inside `AutoCallTwo`.
- Legal plays: `ObtainLegal`.
- Trick resolution: `DecideWinner`.
- Scoring: `CalculateScore` with `ScoreMode` and `HardScore`.
- Rendering: `DrawCards`, `DrawPlayedCards`, `DrawInformation`, `TStatbar.Paint`.
- Options handling: `TOptions.SetupWindow`, `TOptions.OK` (writes back to globals).
- Persistence: profile reads in `TMainWindow.SetUpWindow`; writes in destructor/teardown paths.
- Help hooks: `WinHelp` calls on menu actions.

**Version/History Notes**

- Help file documents v1.1 (20 July 2002). Runtime About reports v1.2 (01 Aug 2002). Source header also lists v1.2 and the same date. Differences between `estwhi_v11.pas` and `estwhi.pas` appear minor (option flags, suit text order), implying 1.2 is primarily cosmetic/maintenance.

**Summary**

This repository is a complete, self‑contained Windows 3.1 card game implemented in Turbo Pascal’s ObjectWindows. Logic and UI are tightly coupled in a single Pascal unit. The bidding AI uses per‑rank heuristics; trick play by bots is random but legal. Scoring supports classic and “squared” modes with an optional hard‑score penalty on zero bids when total bids are low. Porting or extending the project will primarily involve isolating rules/state from Win16 UI and upgrading the toolchain.
